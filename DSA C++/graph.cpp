

https://www.geeksforgeeks.org/print-all-shortest-paths-between-given-source-and-destination-in-an-undirected-graph/
class Graph{
    private:
        char board[15][15] = {
            {'0', '0', '1', '1', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', 'F'},
            {'0', '1', '0', '1', '0', '0', '0', '0', '0', '1', '0', '0', '0', '0', '0'},
            {'0', '0', '1', '1', '0', '0', '1', '1', '0', '0', '0', '0', '0', '0', '0'},
            {'1', '1', '0', '0', '0', '0', '1', '1', '0', '1', '0', '0', '0', '0', '0'},
            {'X', '1', '1', '0', '1', '0', '0', '0', '0', '1', '0', '0', '0', '0', '0'},
            {'0', '0', '1', '1', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0'},
            {'0', '1', '0', '1', '0', '0', '0', '0', '0', '1', '0', '0', '0', '0', '0'},
            {'0', '0', 'X', '1', '0', '0', '1', '1', '0', '0', '0', '0', '0', '0', '0'},
            {'X', '1', '0', '0', '0', '0', '1', '1', '0', '1', '0', '0', '0', '0', '0'},
            {'X', '1', '1', '0', '1', '0', '0', '0', '0', '1', '0', '0', '0', '0', '0'},
            {'0', '0', '1', '1', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0'},
            {'0', '1', '0', '1', '0', '0', '0', '0', '0', '1', '0', '0', '0', '0', '0'},
            {'0', '0', 'X', '1', '0', '0', '1', '1', '0', '0', '0', '0', '0', '0', '0'},
            {'X', '1', '0', '0', '0', 'X', '1', '1', '0', '1', '0', '0', '0', '0', '0'},
            {'X', '1', '1', '0', '1', '0', '0', '0', '0', '1', '0', '0', '0', '0', '0'}
        };

    public:
        Graph(){
            // dimensions of graph
            int m = board.size();
            int n = board[0].size(); 
        }

        int findShortestPath(){

        }
};

// class Graph:
//     def __init__(self):
        // self.board = [
        //     ['0', '0', '1', '1', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', 'FLAG'],
        //     ['0', '1', '0', '1', '0', '0', '0', '0', '0', '1', '0', '0', '0', '0', '0'],
        //     ['0', '0', '1', '1', '0', '0', '1', '1', '0', '0', '0', '0', '0', '0', '0'],
        //     ['1', '1', '0', '0', '0', '0', '1', '1', '0', '1', '0', '0', '0', '0', '0'],
        //     ['X', '1', '1', '0', '1', '0', '0', '0', '0', '1', '0', '0', '0', '0', '0'],
        //     ['0', '0', '1', '1', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0'],
        //     ['0', '1', '0', '1', '0', '0', '0', '0', '0', '1', '0', '0', '0', '0', '0'],
        //     ['0', '0', 'X', '1', '0', '0', '1', '1', '0', '0', '0', '0', '0', '0', '0'],
        //     ['X', '1', '0', '0', '0', '0', '1', '1', '0', '1', '0', '0', '0', '0', '0'],
        //     ['X', '1', '1', '0', '1', '0', '0', '0', '0', '1', '0', '0', '0', '0', '0'],
        //     ['0', '0', '1', '1', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0'],
        //     ['0', '1', '0', '1', '0', '0', '0', '0', '0', '1', '0', '0', '0', '0', '0'],
        //     ['0', '0', 'X', '1', '0', '0', '1', '1', '0', '0', '0', '0', '0', '0', '0'],
        //     ['X', '1', '0', '0', '0', 'X', '1', '1', '0', '1', '0', '0', '0', '0', '0'],
        //     ['X', '1', '1', '0', '1', '0', '0', '0', '0', '1', '0', '0', '0', '0', '0']
        // ]

//     def findShortestPath(self):
//         """
//         Given a 15x15 board with cells '0' (open path), '1' (obstacle), 'X’ (starting point), 
//         and 'FLAG' (destination), make a python code that will find the shortest path from a 
//         start cell (‘X') to 'FLAG. Output should be the coordinates of the 'X' with the 
//         shortest path to 'FLAG’.
//         """

//         # X can have multiple starting points
//         xs = self.findXs()
//         m, n = len(self.board), len(self.board[-1])

//         for start_v in xs:
//             self._findShortestPath(start_v)

//     def _findShortestPath(self, v):
//         """
//         v is a coordinate 
//         """
//         x, y = v

//         # base case
//         if "FLAG" in self.board[x][y]:
//             return
        
//         for v in :


//     def findXs(self):
//         xs = []
//         for i in range(self.board):
//             for j in range(i):
//                 if self.board[i][j] == "X":
//                     xs.append([i, j])           
//         return xs