#include <iostream>

class Graph{
    private:
        char board[15][15] = {
            {'0', '0', '1', '1', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', 'F'},
            {'0', '1', '0', '1', '0', '0', '0', '0', '0', '1', '0', '0', '0', '0', '0'},
            {'0', '0', '1', '1', '0', '0', '1', '1', '0', '0', '0', '0', '0', '0', '0'},
            {'1', '1', '0', '0', '0', '0', '1', '1', '0', '1', '0', '0', '0', '0', '0'},
            {'X', '1', '1', '0', '1', '0', '0', '0', '0', '1', '0', '0', '0', '0', '0'},
            {'0', '0', '1', '1', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0'},
            {'0', '1', '0', '1', '0', '0', '0', '0', '0', '1', '0', '0', '0', '0', '0'},
            {'0', '0', 'X', '1', '0', '0', '1', '1', '0', '0', '0', '0', '0', '0', '0'},
            {'X', '1', '0', '0', '0', '0', '1', '1', '0', '1', '0', '0', '0', '0', '0'},
            {'X', '1', '1', '0', '1', '0', '0', '0', '0', '1', '0', '0', '0', '0', '0'},
            {'0', '0', '1', '1', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0'},
            {'0', '1', '0', '1', '0', '0', '0', '0', '0', '1', '0', '0', '0', '0', '0'},
            {'0', '0', 'X', '1', '0', '0', '1', '1', '0', '0', '0', '0', '0', '0', '0'},
            {'X', '1', '0', '0', '0', 'X', '1', '1', '0', '1', '0', '0', '0', '0', '0'},
            {'X', '1', '1', '0', '1', '0', '0', '0', '0', '1', '0', '0', '0', '0', '0'}
        };

    public:
        int m; 
        int n;
        Graph(){
            // dimensions of graph
            m = sizeof(board) / sizeof(board[0]);
            n = sizeof(board[0]) / sizeof(board[0][0]);
        }

        int findShortestPath(){
            /*
            Given a 15x15 board with cells '0' (open path), '1' (obstacle), 'X’ (starting point), 
            and 'FLAG' (destination), make a python code that will find the shortest path from a 
            start cell (‘X') to 'FLAG. Output should be the coordinates of the 'X' with the 
            shortest path to 'FLAG’.
            */
            std::cout << m << " " << n;
        }
};


int main(int argc, char** argv){
    Graph g;
    g.findShortestPath();

    return 0;
}

// class Graph:
//     def __init__(self):
        // self.board = [
        //     ['0', '0', '1', '1', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', 'FLAG'],
        //     ['0', '1', '0', '1', '0', '0', '0', '0', '0', '1', '0', '0', '0', '0', '0'],
        //     ['0', '0', '1', '1', '0', '0', '1', '1', '0', '0', '0', '0', '0', '0', '0'],
        //     ['1', '1', '0', '0', '0', '0', '1', '1', '0', '1', '0', '0', '0', '0', '0'],
        //     ['X', '1', '1', '0', '1', '0', '0', '0', '0', '1', '0', '0', '0', '0', '0'],
        //     ['0', '0', '1', '1', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0'],
        //     ['0', '1', '0', '1', '0', '0', '0', '0', '0', '1', '0', '0', '0', '0', '0'],
        //     ['0', '0', 'X', '1', '0', '0', '1', '1', '0', '0', '0', '0', '0', '0', '0'],
        //     ['X', '1', '0', '0', '0', '0', '1', '1', '0', '1', '0', '0', '0', '0', '0'],
        //     ['X', '1', '1', '0', '1', '0', '0', '0', '0', '1', '0', '0', '0', '0', '0'],
        //     ['0', '0', '1', '1', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0'],
        //     ['0', '1', '0', '1', '0', '0', '0', '0', '0', '1', '0', '0', '0', '0', '0'],
        //     ['0', '0', 'X', '1', '0', '0', '1', '1', '0', '0', '0', '0', '0', '0', '0'],
        //     ['X', '1', '0', '0', '0', 'X', '1', '1', '0', '1', '0', '0', '0', '0', '0'],
        //     ['X', '1', '1', '0', '1', '0', '0', '0', '0', '1', '0', '0', '0', '0', '0']
        // ]

//     def findShortestPath(self):
//         

//         # X can have multiple starting points
//         xs = self.findXs()
//         m, n = len(self.board), len(self.board[-1])

//         for start_v in xs:
//             self._findShortestPath(start_v)

//     def _findShortestPath(self, v):
//         """
//         v is a coordinate 
//         """
//         x, y = v

//         # base case
//         if "FLAG" in self.board[x][y]:
//             return
        
//         for v in :


//     def findXs(self):
//         xs = []
//         for i in range(self.board):
//             for j in range(i):
//                 if self.board[i][j] == "X":
//                     xs.append([i, j])           
//         return xs